# 1. 运行时内存结构

JVM内存结构:

![](http://img.zqqiliyc.love/jvm/jvm_memory_struct.jpg)

# 2. 类加载子系统

负责从文件系统或网络中加载class文件。

- ClassLoader只负责加载类文件，至于它是否可以运行，则由执行引擎决定。

- 加载的类信息存放于一块称为方法区的内存空间中。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量(这部分常量是class文件中常量池部分的内存映射)

## 2.1 加载

1. 通过类的全限定名获取定义此类的二进制字节流

2. 将这个字节流所代表的二进制静态存储结构转化为方法区的运行时数据结构

3. **在内存中生成一个代表这个类的java.lang.Class对象**，作为方法区这个类的各种数据的访问入口。

## 2.2 链接

1. 验证(verify)，确保class文件的正确性，符合虚拟机规范，确保不会危害虚拟机的安全。主要包括文件格式的验证，元数据验证，字节码验证和符号引用验证。

2. 准备(prepare)。
   
   1. 为类变量分配内存并且设置该类变量的初始默认值，即“0”值。
   
   2. 这里不包含用final修饰的static变量，因为final在编译时就会分配了，准备阶段会显示初始化。
   
   3. 这里不会为实例变量分配初始化，类变量会在方法区中，而实例变量会随着对象在堆中分配。

3. 解析(resolve)。
   
   1. 将常量池内的符号引用转为直接引用的过程。
   2. 事实上，解析操作往往会伴随着JVM在执行完初始化后再执行。
   3. 符号引用就是一组符号来描述所引用的目标
   4. 解析动作主要针对类或接口，字段，类方法，接口方法，方法类型等。

## 2.3 初始化(initialization)。

1. 初始化阶段就是执行类构造器的<clinit>的过程
2. 此方法不需要定义，由javac自动收集类中的所有类变量的赋值动作和静态代码块中的代码合并而来。
3. 类构造器中的指令按源文件中出现的顺序执行。
4. <clinit>不同于构造器。（构造器是虚拟机视角下的<init>()方法）。
5. 若该类具有父类，虚拟机会保证在该类的<clinit>执行前，父类的<clinit>方法已经执行完毕。
6. 虚拟机必须保证一个类的<clinit>方法在多线程的环境下会同步加锁。

# 3. 类加载器的分类

- 引导类加载器

- 扩展类加载器

- 系统类加载器

# 4. 双亲委派机制

JVM对class文件采用**按需加载**机制。

- - -

- 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
- 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
- 如果BootStrapClassLoader加载失败(例如在$JAVA_HOME/jre/lib里未查找到该class)，会使用ExtClassLoader来尝试加载；
- 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

---

双亲委派的优势：

- 系统类防止内存中出现多份同样的字节码

- 保证Java程序安全稳定运行

# 5. 对类加载器的引用

JVM必须知道一个类型是由启动类加载器加载的还是用户自定义类加载器加载的。如果是后者，则JVM会将该类加载器的一个引用作为类型信息的一部分存入方法区中。当解析一个类型带另一个类型的引用时，JVM必须保证这两个类型的类加载器一定是相同的。

# 6. 类的主动使用和被动使用

![](http://img.zqqiliyc.love/jvm/20221127154054.png)

由此可以看出当一个类中只声明的许多静态常量时，对其访问并不会导致该类的加载。
