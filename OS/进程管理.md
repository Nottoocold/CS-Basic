# 1. 进程与线程

## 1.1 进程

进程的封闭性指的是，进程的执行结果与进程执行的速度无关，只取决于进程本身，不受外界影响。

同一系统的进程或线程可以由系统调用的方法被不同的进程或线程多次使用。

引入进程的概念是为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。

为了使参与并发运行的程序能够独立地运行，必须为之配置一个数据结构，称为(Process Control Block)PCB。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由**数据段，程序段和PCB**三部分构成了进程实体。所谓创建进程，实质上创建进程的PCB，撤销进程也是销毁PCB。**PCB是进程存在的唯一标识**。

从不同角度，进程有不同的定义：

- 进程是程序的一次执行过程。

- 进程是一个程序及其数据在其处理机上顺序执行时所发生的活动。

- 进程是具有独立功能的程序在一个数据集上运行的过程，它是系统进行资源分配和调度的独立单位。

### 1.1.1进程的状态

进程有5态：创建态、就绪态、运行态、阻塞态、终止态。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png)

上图值得品读！PCB中会有一个字段state标识进程的状态。

### 1.1.2进程的组织

两大组织方式：链式组织和索引组织。

链式组织：操作系统会根据进程状态将PCB分为多个队列，管理一系列指向进程队列的指针。

索引组织：根据进程状态建立索引表，操作系统持有指向各个索引表的指针，索引表项指向PCB。

### 1.1.3进程的控制

概念：进程控制的主要功能是对系统中所有的进程进行有效的管理，具有创建新进程，撤销已有进程，实现进程转换等的功能。**其实就是实现进程状态的转换。**

进程控制需要使用“原语”

通常情况下，CPU每执行完一次指令，都会检查是否有外部中断信号。为了实现原子操作，可以使用关中断指令和开中断指令这两个特权指令实现。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.png)

- 创建原语，申请空白PCB，分配进程所需资源，初始化PCB，将PCB插入就绪队列，如用户登录、作业调度（程序从外存到内存）、提供服务、应用请求。

- 撤消原语，从PCB集合中找到目标PCB，若进程正在运行，则立即剥夺其CPU资源，终止其所有子进程，将该进程的所有资源归还给父进程或操作系统，删除PCB。

- 阻塞原语，找到阻塞进程的PCB，保护进程运行的现场，将PCB中的状态设置为阻塞态，暂时停止进程的运行，将PCB插入相应事件的队列。

- 唤醒原语，在事件等待队列中找到目标PCB，将PCB从等待队列中移除，进行就绪态，将PCB插入就绪队列，等待被调度。

- 切换原语，（运行态－＞就绪态、就绪态－＞运行态）将运行环境信息存入PCB，PCB移入相应队列，选择另一个进程执行，并更新PCB，根据PCB恢复新进程所需运行环境。

**阻塞原语和唤醒原语通常成对出现。**

进程的运行环境，CPU寄存器中的值需要在进程下机时保存到PCB中（必要的寄存器中的值），再次上机时再恢复。

### 1.1.4进程通信

(Inter-Process Communication) IPC 进程通信是指两个进程之间产生数据交互。

进程是分配系统资源的单位(包括内存空间)，故进程的内存地址空间是相互独立的。某个进程是无法直接访问其他进程的内存地址空间的。

- 方式一，**共享存储空间**，Linux中，如何实现共享内存，

```c
int shm_open() // 使用此系统调用开辟共享内存地址空间
void *mmap() // 通过次系统调用，将共享内存区映射到自己的虚拟地址空间中
```

当操作系统划出这片内存区域后，数据的形式、存放位置都由通信进程控制，而不是操作系统，这种共享方式很快，是一种高级通信方式。还有一种是基于数据结构的共享方式，但是这种通信限制较多，速度慢，是低级通信方式。

- 方式二，**消息传递**，进程的数据交互以一种格式化的消息（Message）为单位，进程通过操作系统提供的发送消息和接收消息两个原语操作进行数据交换。消息头，消息体。是一种直接通信方式，即通信进程直接指明自己要发送给谁或接受谁的消息。间接通信则是以中间媒介进行通信，可以理解为中间体是“信箱”。**当进程发送消息时，系统将消息从用户缓冲区复制到内核中的消息缓冲区，然后将消息缓冲区挂入消息队列。进程发送的消息保存在消息队列中，直到被另一进程接受。当进程接受消息时，系统从消息队列中解挂消息缓冲区，将消息从内核消息缓冲区复制到用户消息缓冲区，然后释放消息缓冲区。**

- 方式三，**管道通信**，数据流动是单向的，想象一下“水管”，在OS眼里，“管道”是一种共享文件，又称pipe文件，也就是内存中的一块缓冲区，在Linux中，这种共享文件的大小是4KB，FIFO，写数据读数据是有限制的。。循环队列。。？对管道的访问是互斥的，若管道被写满，则进程被阻塞，被读完，则也被阻塞。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.png)

## 1.2 线程

若没有线程，一个进程就不能并发的执行各种操作，比如QQ，能文字聊天同时又能视频，又能撩骚。。。

线程：**轻量级**的进程，是一个基本的CPU执行单元，也是程序执行流的最小单位，由线程ID，程序计数器，寄存器集合，堆栈组成，是CPU调度的单位，进程是资源分配的基本单位，进程与进程之间可以并发的执行，线程与线程之间也可以并发执行，提高系统的并发度。

线程与进程的对比：

- 调度，在同一个进程中，线程的切换不会引起进程切换，但不同进程间的线程切换会引起进程的切换。
- 并发性，不仅进程间可以并发执行，而且各个线程之间也可以并发执行。
- 拥有资源，进程是系统中拥有资源的基本单位，而线程不需要资源（仅需要线程运行时必要的资源来保证线程的独立执行），但线程可以访问其隶属进程的资源，因为同一进程的所有线程共享内存空间。
- 独立性，那个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。
- 系统开销，线程切换时，只需要保存和设置少量寄存器内容，开销小，此外，由于多个线程可以共享进程的地址空间，所以线程间同步和通信非常容易实现，甚至不需要操作系统的干预。
- 支持多处理机，各个线程可以并行占用多个处理机资源。

从**系统开销**方面看：传统的进程间并发，需要切换系统的运行环境，开销大；而引入线程后，线程间并发，若是同一进程内的线程切换，则不需要切换运行环境，开销小，并发所带来的系统开销变小。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B1%9E%E6%80%A7.png)

### 1.2.1线程的实现方式

线程的实现方式

- 用户级线程 ，由程序员完成（线程库），OS看到的还是进程，用户态运行，当一个线程阻塞后，整个进程也会阻塞，并发度不高
- 内核级线程 ，线程的管理由OS统一管理（每个线程都有TCB [Thread Control Block]），并发度高，多线程可在多核上并行运行，管理成本大，开销大。**<u>内核级线程才是OS调度的单位。</u>**

多线程模型，用户级线程与内核级线程间的映射关系：

- 一对一模型，一个用户级线程对应一个内核级线程
- 一对多模型，多个用户级 -> 一个内核级
- 多对多模型，多 -> 多

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93.png)

## 问题：

1. 为什么要引入进程？
   在多道程序运行的环境下，进程之间需要共享系统资源，因此会导致各程序之间会有相互制约关系，程序执行会导致间断性特征。这些特征都是在程序执行时发生的，是动态的过程，而传统程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿、也无法看出它与其他程序之间的关系，因此程序这个静态概念不能如实反映出程序并发执行的过程特征。为了深刻描述程序的动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。

2. 什么是进程？进程由什么组成？
- 进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态概念，是一个活动的实体。它不只是代码本身，还包括当前活动，程序计数器的值和处理寄存器的内容来表示。

- 进程由程序段、数据段和PCB组成。其中PCB是一个进程存在的唯一标识，程序段是进程运行的程序代码，数据段存储程序运行过程中相关的一些数据。
3. 进程是如何解决问题的？
   进程把能够识别程序运行态的一些变量存放在PCB中，通过这些变量的状态系统能够更好地理解一个进程的运行状态，并在适当时进行进程切换，以避免一些资源浪费，甚至划分出更小的调度单位。

## 1.3 处理机调度

在多道程序环境中，进程数量往往多与处理机数量，因此进程争用处理机的情况在所难免。处理机调度就是对处理机进行分配，即从就绪队列中按照一定算法选择一个进程并将处理机分配给他运行，以实现进程的并发执行。
处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。

**高级调度(作业调度)，中级调度(内存调度)，低级调度(进程调度)，**

- 高级调度，操作系统需要从外存的作业队列中挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次，调入时建立PCB，调出时撤销PCB。
- 低级调度，分配处理机资源
- 中级调度，当内存不足时，操作系统会将进程的数据调出外存，等进程空闲或进程需要运行时再重新调入内存，被调出的进程处于挂起状态，PCB处于挂起队列，*中级调度*就是将挂起进程重新调入内存的过程。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%B0%83%E5%BA%A6%E5%88%86%E7%B1%BB.png)

### 进程调度的时机和方式

**临界资源**，一个时间段内只允许一个进程访问的资源。各进程需要互斥的访问临界区资源。

**临界区**，执行访问临界资源的那段代码。临界区可分为**内核程序临界区**和**普通临界区**。

进程在**操作系统内核临界区中不能进行进程调度与切换**

**内核程序临界区**，一般是用来访问某种内核数据结构的，比如进程的就绪队列。此时不能进行进程调度。

进程调度方式

- 非剥夺调度方式，只允许进程主动放弃处理机
- 剥夺调度方式，比如分时操作系统，实时操作系统。

闲逛进程，是调度程序永远可以i选择的备胎，当没有其他的就绪进程时，闲逛进程就开始上机了。

特点是，优先级最低；可以是0地址指令(不需要访存)，占一个完整的指令周期，能耗低。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87.png)

## 进程调度算法

- **先来先服务(FCFS)First Come First Serve**，按照作业或进程到达的先后顺序执行调度算法，是非抢占式的算法。优点是实现简单，公平；缺点是对于排在长进程(作业)后面的短进程(作业)来说，可能需要等待很长时间才能被调度，带权周转时间大，对短作业不友好。不会导致进程饥饿
- **短作业优先算法(SJF)Shortest Job First**，顾名思义，"短"指进程需要被服务的时间少，一般是非抢占式算法，但也存在抢占式算法SRTN,Shortest Remaing Time Next,最短剩余时间优先算法。优点，“最短的”平均等待时间，平均周转时间。缺点，对短作业有利，对长作业不利，可能产生饥饿现象
- **高响应比优先算法(HRRN)Highest Response Ratio Next**，在每次调度时，先计算各个作业或进程的响应比，会选择响应比最高的作业或进程进行调度。***<u>响应比 = (等待时间 + 要求服务时间) / 要求服务时间</u>***，非抢占式算法，当运行的进程主动放弃处理机时，才需要调度，才会计算响应比。

以上三种算法常用于早期的批处理系统，因为他们都不关心**响应时间**，也不关心任务的紧急程度，因此对于用户体验来说，交互性很差。

- **时间片轮转调度算法RR**,是一种进程调度，抢占式算法，由时钟中断控制，时间片不可以过大，因为过大可能会导致此算法变成先来先服务的调度算法，失去了响应快的特点；另一方面，因为进程切换需要需要时间代价，因此也不能把时间片设置的太小。适用分时操作系统。

- **优先级调度算法**，每个作业或进程都有一个优先级，每次调度选择一个优先级高的进行调度，有非抢占式和抢占式两种。此算法区分任务的紧急程度，适用于实时操作系统，可灵活调整对作业或进程的偏好程度，若不断有高优先级的进程到来，则可能发生饥饿现象。
  
  - 一般来说，系统进程优先级大于用户进程优先级；I/O繁忙型进程优先级大于CPU繁忙型进程(因为I/O设备可以和CPU并行运行)
  - 若采用动态优先级，则，若某进程等待了很长事件，可以适当提升其优先级；若某进程占用了处理机很长事件，可以适当降低其优先级；若某进程频繁地进行I/O操作，可以适当提升其优先级。 

- **多级反馈队列算法**，是对时间片轮转调度算法和优先级调度算法的综合发展。此算法若有很多短运行时间的进程到来则可能导致低优先级队列中的进程饥饿，通常用于进程调度。
    **算法规则：**
  
  1. 设置多个就绪队列，并为每个队列赋予不同优先级。各级队列优先级从高到低，时间片从小到大。
  
  2. 新进程到达时，先进入第1级队列，按FCFS规则等待调度，若时间片用完进程还未结束，则进入下一级队列；若在下一级队列中调度后，还是没有运行完，就再次进入第3级队列，依此类推；若此时已经在最低一级队列，则放回当前队列的队尾；当进程被降到第n级队列后，在第n级队列中便采用时间片轮转方式运行。
     
     3. 只有当第k级队列为空时，才会为第k+1级队列的队头进程分配时间片。仅当第1~i-1级队列为空时，才会调度第i级队列，若处理机正在执行第i级队列的某进程时，有新进程进入任意优先级高的队列，则处理机会立即剥夺当前运行的进程，将CPU分配给新到的高优先级进程。
     
     **优点：**
  
  3. 终端型作业用户：短作业优先。
  
  4. 短批处理用户：周转时间较短。
  
  5. 长批处理用户：经过前面几个队列得到了部分执行，不会长期得不到处理。
  
  此三种算法适用于交互式系统的调度策略。
  
  下图是几种常见的进程调度算法：
  
  <img title="" src="https://raw.githubusercontent.com/Nottoocold/img/main/os/dispatch-process.jpg" alt="" data-align="inline">

## 1.4 进程同步与互斥

- **进程同步**（直接制约关系）需要让进程相互协调地向前推进，进程间要有次序的执行。
- **进程互斥**，指当一个进程需访问某一个临界资源时，另一个想访问该临界资源的进程需要等待，只有当前访问进程访问结束后，释放了资源，才可以被另一个进程访问。（临界资源，指同一个时间段只允许一个进程访问的资源）
  1. 进入区，检查是否可进入临界区，若可进入，则需要上锁
  2. 临界区，执行访问临界资源的代码片段
  3. 退出区，解锁
  4. 剩余区，其余代码

互斥实现的软件方法：

- **单标志法**，**设置一个标志变量，用于指示被允许进入临界区的进程编号，当进程访问完后退出临界区时，将标志改为另一个进程编号，此算法虽然可以实现同一时刻只有一个进程访问临界资源，但是进程间是交替访问的，也就说明标志位的改变必须依赖进程进入临界区，假如此时标志为某一进程编号，但是此进程并没有访问临界资源的打算，则另一个进程也将不能访问临界资源，违背了空闲让进的原则**。

- **双标志先检查法，设置一个bool型数组，数组元素用来标志进程是否想进入临界区，如<u>“flag[0]=true”</u>说明0号进程想进入临界区；当进程想在进入临界区时，会检查其他进程是否需要进入临界区，只有当其他进程不想进入临界区时，当前进程则进入，并把自己的bool数组对应值设为true。此算法的问题在于，当进程并发执行时，由于检查和上锁两个操作不是一气呵成的，所以可能出现临界资源同时被多个进程访问的现象，违背了忙则等待的原则**。

- **双标志后检查法**，**与双标志先检查法相反，即先上锁再检查，但是违背了空闲让进和有限等待的原则。可能出现饥饿现象**。

- **Peterson算法**，**结合双标志和单标志的特性，如果双方都想进入临界区，则可以让进程尝试孔融让梨，做一个有礼貌的进程**。
  
  ![](https://raw.githubusercontent.com/Nottoocold/img/main/os/Petersonsuanfa.png)

谁最后说了客气话，谁就没有主动权，哈哈哈。。此算法违背了**”让权等待“**的原则。

硬件解决方案

- 中断屏蔽方法

- 使用开/关中断指令，不适用于多处理机系统；只适用于操作系统内核进程。

- TestAndSet/TestAndSetLock指令(TS/TSL指令)
  
  ```c
  /*
      适用于多处理机环境
      不满足“让权等待”的原则，因为不满足进入临界区的进程会循环等待，不会让出CPU
  */
  bool TestAndSet(bool *lock){
      bool old;
      old = *lock;
      *lock = true;
      return old;
  }
  
  while(TestAndSet(&lock));
  //临界区代码
  lock=false; // 解锁
  //剩余临界区代码
  ```

- Swap指令(XCHG指令)

**互斥锁，也称自旋锁（获取不到锁时，处于忙等状态，也就是死循环），适用于多处理机系统，**

### 信号量机制

整型信号量和记录型信号量

wait(s) P操作 signal(s) V操作

- 整形信号量，用一个整形变量作为信号量，用来表示系统中某一资源的数量，存在问题，让权等待的原则

- 记录型信号量，
  
  ![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F.png)

### 信号量机制实现进程互斥同步

- 进程互斥

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5.png)

- 进程同步
  
  ![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5.png)

## 生产者-消费者问题

生产者进程和消费者进程

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85.png)

## 读写者问题

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%981.png)

***上述情况可能会造成写者“饿死”现象，分析不难可知，当不断有读者进行读操作，则rw信号量一直不会被解锁，所以写者一直都不能写。***

改进方法：

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%982.png)

**w**信号量使得读写都公平，即对进程按到达顺序实现排队。对读写者问题的思考

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%AF%BB%E5%86%99%E8%80%85%E9%97%AE%E9%A2%983.png)

## 哲学家进餐问题

问题解决参考方案一：

- 只允许同时有 n-1 个哲学家进餐

问题解决参考方案二：

- 偶数编号哲学家只允许先拿右边筷子，再拿左边筷子；奇数编号哲学家相反。

问题解决参考方案三：

- 这是互斥信号量mutex=1，表示互斥地取筷子，故哲学家拿筷子这件事必须互斥地进行。这就保证了即使一个哲学家在拿筷子时拿到一半时被阻塞，也不会有其它哲学家继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。

# 1.5 死锁

概念：在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源，导致各进程被阻塞，都无法向前推进的现象**，就是“死锁”，这种现象若无外力干涉，那么这些进程都无法向前推进。

产生死锁的四个必要条件：

- 互斥条件，各进程需要互斥访问某些资源
- 不可剥夺条件，进程已经在访问某资源时，不能被中断访问
- 请求和保持条件，进程在拥有某一资源时，同时又在请求另外的资源，
- 循环等待条件，存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求。
  - **发生死锁时一定存在循环等待，但是发生循环等待时不一定会发生死锁，当系统中同类资源不止一个(循环等待是发生死锁的必要不充分条件)**

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5.png)

## 预防死锁(效率不高)

- 破坏互斥条件，比如SPOOLing技术，但是应用不广泛
- 破坏不剥夺条件，
  - 当某进程申请的资源得不到分配时，它必须立即释放当前已占有的所有资源，待以后需要时再重新分配，即某些资源即使未使用完，也要立即释放（可能会导致饥饿）
  - 当某进程需要的资源被其他进程所占有的时候，可由操作系统协调，经想要的资源强行剥夺，此情况需要考虑进程的优先级（一般适用于易恢复运行环境的资源）
- 破坏请求和保持条件，
  - 静态分配资源法，当某进程在上机之前，就将它需要的资源都分配给它，若资源没有分配成功，则不投入运行，否则一旦上机就不再申请资源。（可能导致饥饿，系统资源分配不均衡，资源利用率低）
- 破坏循环等待条件，
  - 顺序资源分配法，首先给资源编号，规定每个进程按资源编号递增的顺序分配资源。只有当进程已占有小编号资源时，才有资格申请更大编号的资源。所以已持有大编号资源的进程不可能逆向申请小编好的资源。（不好扩展系统资源，导致资源利用率低，编程麻烦）

## 避免死锁

动态策略，避免死锁。

- 安全序列，指系统按照某种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是处于安全状态，安全序列可能存在多个。

- 不安全状态，如果分配了资源后，系统找不到一个安全序列，则系统就进入了不安全状态，意味着之后的进程**可能**都无法顺利进行，当然，若某进程归还了资源，系统还是可能回到安全状态的，不过我们总是会考虑最坏的情况。
  
  **所以，当系统中存在安全序列时，就一定不会发生死锁；系统进入不安全状态，就可能会发生死锁。**

**银行家算法**，

- ***核心思想，当进程需要申请资源时，系统在为其分配资源之前，会预判分配之后会不会导致系统进入不安全状态，若会使系统进入不安全状态，则不进行分配，使进程进入阻塞状态。***

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95.png)

## 死锁检查和解除

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B.png)

死锁的解除

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4.png)
