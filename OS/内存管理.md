# 1. 内存管理

概念：

- 内存空间的分配和回收

- 内存空间的扩充（实现虚拟性）

- 地址转换

- 存储保护

## 1.1 地址转换

- 绝对装入
  
  在编译时，如果知道程序将放到内存中的位置，编译程序就会在编译时产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序装入内存。

- 可重定位装入
  
  编译、链接后的装入模块中的地址都是从0开始的，指令中使用的地址、数据存放的位置都是相对于起始地址而言的逻辑地址。可根据当前的内存情况，将装入模块装入到内存中的合适位置，转入时对地址进行重定向，将逻辑地址转化为物理地址，地址变换实在装入时一次性完成的。

- 动态运行时装入
  
  编译、链接后的装入模块的地址都是从0开始的，装入程序把装入模块装入内存后，并不会将逻辑地址转换为物理地址，而是**把地址转换推迟到程序真正需要运行时才进行**，因此，此方法需要一个**重定位寄存器**的支持来存放该进程的起始地址。

## 1.2 存储保护

- 进程只能访问自己的进程地址空间的内容，实现方式：1.设置上下限寄存器；2.利用**重定位寄存器、界地址寄存器**进行判断。

## 1.3 内存空间的扩充

- 覆盖技术
    覆盖技术的思想：对于程序大小大于内存大小的程序，将程序分为多个段（多个模块），将常用的段常驻于内存，不常用的段在需要时再调入内存。已经被淘汰。

- 交换技术
    当内存空间紧张时，系统将内存中某些进程换出外存，把外存中的某些已具备运行条件的进程换入内存，进程在外存和内存间动态调度（中级调度）,PCB不会被换出内存。

## 1.4 内存空间的分配和回收

### 1.4.1 连续分配方式

- 单一连续分配，此方式只允许内存中存在一个用户进程，无外部碎片，有内部碎片，存储器利用率很低。

- 固定分区分配，将内存中整个用户空间划分为若干个固定大小的分区，每个分区只装入一道作业，无外部碎片，有内部碎片。

- 动态分区分配，不会预先划分内存分区，而是在进程装入内存时，根据进程大小动态的分配内存分区，并使分区大小正好适合进程需要。有外部碎片，无内部碎片。

**因为动态分区分配算法对系统性能有很大影响，因此人们对它进行了广泛的研究。**

### 1.4.2 动态分区分配算法

- **首次适应算法**，每次都从低地址开始寻找，直到能找到一个能满足大小的空闲分区。

- **最佳适应算法**，因为动态分区分配算法是连续分配内存的方式，所以为了保证“大进程”到来时能有足够的空闲分区，所以分配时优先使用更小的空闲区间。容易积攒出很多小的外部碎片。

- **最坏适应算法**，优先使用更大的空闲分区。。这么分配多了。有考虑到后面到的大进程吗？

- **临近适应算法**，改善首次使用算法（可能会造成低地址部分出现很多的小空闲分区，而每次分配查找时，都要经过从低地址部分开始查找，开销大），so每次分配查找从上次结束的位置开始查找，可使用循环链表按地址递增的顺序排列**空闲分区表数据结构**。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95.png)

首次适应算法效果最好。

# 2. 分页存储管理

- **概念**，将内存分为一个个大小相等的分区，每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“页框号”，页框号从0开始。一个进程对应一张页表。  

- 将**进程的逻辑地址空间也分为与页框大小相等**的一个个部分，**每个部分称为一个“页”或”页面“**，每个页面也有编号，称为**页号**，页号也是从0开始。  

- 操作系统以页框为单位为各个进程分配内存空间，**进程的每一个页面放入页框中，也就是说进程的页面与操作系统的页框有一一对应的关系**，各个页面不连续存放，可以放到不相邻的页框中。

- **页表**，是一种数据结构，每个页框大小要和每个页面大小相等；假设有4GB内存，进程页面大小是4KB，则可以计算出内存中共有2^32B/2^12=2^20个页框，则至少需要20bit**存储页框编号**，因为计算机是按字节分配，所以需要3字节来存储**页框编号，页表项=页号+内存块号**，而页面号是不需要空间存储的，因为页表是一块连续的内存空间，当我们知道了该页表的起始地址时，就可以直接算出任意一个编号的页号的起始地址 p = baseAddr + 3*offset

- 每个进程的PCB控制块中都存有一份**页表**（记录进程的页面号与页框号（内存块号）之间的映射关系，**每个页表项由进程的页号和内存的页框号组成**)

- 指令给出的逻辑地址结构就可以有以下结构：**页号P + 页内偏移量W**

- **页表长度**指的是页表中有多少个页表项，即该进程有多少个页面

- **页表项长度**指的是页表相所占的存储空间大小，即内存块号至少几个字节

- **页面大小**指的是一个页面占多大的存储空间，通常为4KB

## 2.1 实现逻辑地址到物理的转换

虽然进程的各个页面在内存中是离散存储的，但是每个页面内部是连续的。基本地址变换机构，用于实现逻辑地址到物理地址转换的一组硬件机构。

- 确定逻辑地址A对应的页号P

- 找到该页号P在内存中对应的页框号，然后算出该页框号的起始地址

- 找到该逻辑地址A的页内偏移量W

- 所以某逻辑地址A对应的**物理地址=P号页面在内存中的起始地址+页内偏移量W**

### 2.1.1 如何确定一个逻辑地址对应的页号，页内偏移量，物理地址？

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png)

- 页号P = 逻辑地址/页面长度

- 页内偏移量W=逻辑地址%页面长度

- 假设计算机用32位来表示逻辑地址，若将页面大小设为2的幂4KB=2^12B，则32位二进制bit就分为前20bit表示页号，后12bit表示页内偏移量 

- 综上得出结论：页面大小只要满足是2的整数次幂，就可以将**逻辑地址**拆分为（页号+页内偏移量）

- 地址变换过程如下图所示；

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.png)

- 还有一个结论是：就是**将页表中记录的物理块号拼接上页内偏移量就能得出对应的物理地址** 

- 最重要的特征：若有K位表示”页内偏移量“，则说明该系统中一个页面的大小是2^K个内存单元，如果有M位表示”页号“，则说明在系统中，一个进程最多有2^M个页面，页表寄存器=页表基址+页表长度
  ![1](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png)  

### 2.1.2 使用快表(TLB)进行地址变换

快表是一种高速缓存，用来存放最近访问过的页表项的副本，每次变换地址时，会先检查页号的合法性，然后查快表，快表命中则只访问一次主存，若未命中，则访问两次主存(因为页表是在主存中，第一次访问到页框中的地址，第二次访问真正的地址单元)。

### 2.1.3 多级页表

- 问题一，页表必须连续存放，因此当页表很大时，就需要很大一块连续的内存块。

- 问题二，没有必要让整个页表常驻内存，因为进程很可能在一段时间内只访问特定的几个页。

![2](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%8E%9F%E7%90%86.png)

---

![3](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png)

- - -

![4](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%A7%A3%E5%86%B3%E9%A1%B5%E8%A1%A8%E4%B8%8D%E9%9C%80%E8%A6%81%E5%85%A8%E5%9C%A8%E5%86%85%E5%AD%98.png)

- - -

# 3. 分段存储管理

概念：按照程序自身的逻辑关系划分为若干个段，每个段都有自己的段名，**每段从0开始编址**。内存分配的规则：按段进行分配，每个段在内存中连续分配，但是段与段之间可以不相邻。
段表项 = 段号(不显示存储) + 段长(该段大小) + 基址(对应内存块的基址)，每个段对应一个段表项。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.png)

## 3.1 分段与分页的对比

- 页是信息的物理单位。分页的主要目的是为了实现分散，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。

- 段是信息的逻辑单位。分段的主要目的是更好地满足用户的需求。一个段通常包含着一组属于一个逻辑模块的信息。分段是对用户可见的，用户编程时需要显示地给出段名。

- 页的大小固定，由系统决定；段的大小由用户决定，需要用户显示给出。

- 分页的用户进程是一维的，程序员只需要给出逻辑地址即可。

- 分段的进程是二维的，需要给出段号和段内地址。

**分段更容易实现信息的共享和保护！**

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E5%AF%B9%E6%AF%94.png)

# 4. 段页式管理

分段+分页管理，集二者之长。

![5](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86.png)

1. 段页式管理中：
- 段表：段号(隐含) + **页表长度(该段中有多少页) + 页表存放块号页号**

- 页表：页号+内存块号
  
  ![6](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%AE%B5%E8%A1%A8-%E9%A1%B5%E8%A1%A8.png)

一个进程只会对应一个段表，但是会对应多个页表。

2. 地址变换
   
   ![7](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png)
   
   - 由逻辑地址得到段号、页号、页内偏移量
   
   - 段号与段表寄存器中的段表长度进行比较，检查是否越界
   
   - 由段表基址和段号得到段表项的首地址
   
   - 根据段表项中的页表长度，检查页号是否越界
   
   - 根据页表基址、页号查询到页表项
   
   - 根据页表项记录的内存块号和逻辑地址中的页内偏移量得到物理地址
   
   - 访问该物理地址表示的内存单元中的内容

# 5. 虚拟内存

## 5.1 概念和特征

采用非连续分配方式（离散分配）

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.png)

---

![8](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E5%BE%81.png)

## 5.2 虚拟内存的实现方式

- 访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存（请求调页功能）

- 内存空间不足时，将内存中暂时用不到的信息换出到外存（页面置换功能）

- 虚拟内存的实现
  
  - 请求分页存储管理
  
  - 请求分段存储管理
  
  - 请求段页式存储管理

不管哪种实现方式，都需要一定的硬件支持。

- 一定容量的外存和内存。
- 页表机制（或段表机制），作为主要的数据结构
- 中断机构，当用户程序要访问的部分尚未调入内存时，则产生却页中断
- 地址变换机构，逻辑地址到物理地址的转换

## 5.3 请求分页管理方式实现请求调页功能和页面置换功能

程序执行过程中，当所访问页面不在内存时，由操作系统将需要访问的页面从外存调入内存；若内存空间不足，由操作系统将内存中暂时用不到的信息换出到外存。

- **页表机制**，数据结构：页号（隐含）+内存块号+**状态位（记录该页是否被调入内存）+访问字段（记录该页被访问的次数）+修改位+外存地址（记录该页所在外存的地址）**

- **却页中断机构**，在请求分页系统中，每当所要访问的页面不存在于内存中时，便产生一个却页中断，请求操作系统将所缺页调入内存。此时应将却页的线程或进程阻塞（调页完成唤醒），若内存中有空闲块，则分配一个块，将要调入的块装入该块，并修改页表中相应的页表项；若此时内存没有空闲块，则要淘汰某页（若淘汰的块在内存期间被修改过，则需要写回内存）。却页中断作为中断，同样经历诸如CPU现场信息保护，分析中断原因，转入却页中断处理程序，恢复CPU环境等几个步骤。但与一般中断对比，它有以下两个明显的区别：
  
  - 在指令执行期间而非一条指令执行完后产生和处理中断信息，属于内部异常
  - 一条指令在执行期间可能产生多次却页中断

- 地址变换机构，请求分页系统的地址变换机构是在分页系统的机构上，为实现虚拟内存，又增加了某些功能而形成的。

![](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.jpg)

![9](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F.png)

## 5.4 页面置换算法

- **最佳置换算法（OPT）**，每次选择淘汰的页面将是以后不会使用，或是在最长时间不在被访问的页面，这样可以保证最低的缺页率。**此算法发生缺页中断的次数大于页面置换的次数，因为只有当内存中无空闲空间的时候采用置换啊。然而此算法的致命缺陷是，需要提前知道访问页面号的序列，这对操作系统来说是不可能的，程序只有在运行时，才能逐渐的确定会访问哪些页面，所以此算法无法实现。**

- **先进先出算法（FIFO）**，每次选择淘汰的页面时最早进入内存的页面，每次需要置换时就将对头页面置换出即可。但是此算法，有一个现象：当分配给某进程的内存块数量增加时，发生缺页中断的次数反而会增加，没有考虑局部性原理。

- **最近最少未使用置换算法（LRU）**，每次淘汰最近最久没有被访问的页面。实现方法：赋予页表项中访问字段记录该页面自上次被访问以来所经历的时间T，换出时，只需选择T最大的，即最近最久未被使用的页面。

- **时钟置换算法（CLOCK）**，最佳置换算法性能最好，但是无法实现；先进先出算法性能最差；最近最久未使用算法，性能虽好，但是需要专门硬件支持，开销很大；时钟置换算法是一种性能和开销较均衡的算法
  
  ![9](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png)

- 改进型的时钟置换算法
  
  ![10](https://raw.githubusercontent.com/Nottoocold/img/main/os/%E6%94%B9%E8%BF%9B%E5%9E%8B%E7%9A%84%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png)

第一优先级：最近没有被访问且没有被修改过的页面。

第二优先级：最近没有被访问但是被修改过的页面。

第三优先级：最近访问过但没修改过的页面

第四优先级：最近访问过且被修改过的页面

## 5.5 页面分配和置换策略

驻留集：指请求分页存储管理中，给进程分配的物理块的集合。

内存分配的策略：

- 固定分配，驻留集大小确定之后不再改变

- 可变分配，先为进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加和减少，即驻留集的大小可变

置换策略：

- 发生却页时只能选进程自己的物理块进行置换

- 可将操作系统保留的空闲块分配给却页进程，也可将别的进程持有的物理块置换到外存，再分配给却页进程。